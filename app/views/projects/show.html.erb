<%= render NavbarComponent.new(project: @project) %>

<div class="w-full z-20 relative overflow-hidden" style="height: calc(100% - 60px)" id="viewport">
  <div id="workspace" class="relative flex">
    <div id="center-point" class="bg-secondaryBg rounded-lg border border-dashed border-gray-300 hover:bg-gray-100 p-4">
      <div class="flex space-x-3 items-start">
        <div class="icon-container icon-md text-2xl mt-1 flex items-center justify-center bg-pink-500 text-white p-1 rounded-full" aria-hidden="true">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus">
            <path d="M12 5v14m-7-7h14"></path>
          </svg>
        </div>
        <div class="flex flex-col min-w-0">
          <p class="text-base font-semibold truncate text-left mb-1 sm:mb-0">Add a Service</p>
          <p class="mac-keyboard-shortcut text-sm">âŒ˜K -&gt; New Service</p>
          <p class="normal-keyboard-shortcut text-sm">Ctrl + K -&gt; New Service</p>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
    #viewport {
        background-image: radial-gradient(circle, rgba(0, 0, 0, 0.25) 1px, transparent 1px);
        background-size: 30px 30px; /* Space between points */
        background-repeat: repeat;
    }
</style>

<script>
    (() => {
        const isMac = navigator.platform.toUpperCase().includes('MAC');

        const macShortcuts = document.querySelectorAll(".mac-keyboard-shortcut");
        const normalShortcuts = document.querySelectorAll(".normal-keyboard-shortcut");

        if (isMac) {
            macShortcuts.forEach(shortcut => shortcut.style.display = "block");
            normalShortcuts.forEach(shortcut => shortcut.style.display = "none");
        } else {
            macShortcuts.forEach(shortcut => shortcut.style.display = "none");
            normalShortcuts.forEach(shortcut => shortcut.style.display = "block");
        }

        document.onkeydown = function (e) {
            if ((isMac && e.metaKey && e.key === "k") || (!isMac && e.ctrlKey && e.key === "k")) {
                e.preventDefault();
                alert("New Service");
            }
        }

        const viewport = document.getElementById("viewport");
        const workspace = document.getElementById("workspace");
        const centerPoint = document.getElementById("center-point");

        let scale = 1;
        const minScale = 0.5;
        const maxScale = 3;
        let translateX = (viewport.clientWidth / 2 - centerPoint.clientWidth / 2);
        let translateY = (viewport.clientHeight / 2 - centerPoint.clientHeight / 2);
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let lastTouchDistance = 0;

        let lastViewportWidth = viewport.clientWidth;
        let lastViewportHeight = viewport.clientHeight;

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const zoom = (delta, originX, originY) => {
            const step = 1.05;
            const oldScale = scale;
            scale = clamp(delta > 0 ? scale / step : scale * step, minScale, maxScale);

            const deltaX = (originX - translateX) * (1 - scale / oldScale);
            const deltaY = (originY - translateY) * (1 - scale / oldScale);

            translateX += deltaX;
            translateY += deltaY;
            updateTransform();
        };

        const pan = (dx, dy) => {
            translateX += dx;
            translateY += dy;
            updateTransform();
        };

        const updateTransform = () => {
            workspace.style.transformOrigin = "0 0";
            workspace.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            viewport.style.backgroundSize = `${30 * scale}px ${30 * scale}px`;
            viewport.style.backgroundPosition = `${translateX}px ${translateY}px`;
        };

        const handleResize = () => {
            const deltaWidth = viewport.clientWidth - lastViewportWidth;
            const deltaHeight = viewport.clientHeight - lastViewportHeight;

            translateX += deltaWidth / 2;
            translateY += deltaHeight / 2;

            lastViewportWidth = viewport.clientWidth;
            lastViewportHeight = viewport.clientHeight;

            updateTransform();
        };

        const stopDragging = () => {
            if (isDragging) {
                isDragging = false;
                viewport.style.cursor = "grab";
            }
        };

        updateTransform();

        viewport.addEventListener("wheel", (e) => {
            e.preventDefault();
            if (e.ctrlKey) {
                zoom(e.deltaY, e.clientX, e.clientY - 60);
            } else {
                pan(-e.deltaX, -e.deltaY);
            }
        }, {passive: false});

        viewport.addEventListener("touchstart", (e) => {
            if (e.touches.length === 2) {
                lastTouchDistance = getTouchDistance(e.touches);
            } else if (e.touches.length === 1) {
                isDragging = true;
                startX = e.touches[0].clientX - translateX;
                startY = e.touches[0].clientY - translateY;
            }
        });

        viewport.addEventListener("touchmove", (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const currentDistance = getTouchDistance(e.touches);
                const delta = currentDistance - lastTouchDistance;
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                zoom(delta, centerX, centerY);
                lastTouchDistance = currentDistance;
            } else if (e.touches.length === 1 && isDragging) {
                translateX = e.touches[0].clientX - startX;
                translateY = e.touches[0].clientY - startY;
                updateTransform();
            }
        }, {passive: false});

        viewport.addEventListener("touchend", stopDragging);

        viewport.addEventListener("mousedown", (e) => {
            isDragging = true;
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
            viewport.style.cursor = "grabbing";
        });

        viewport.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateTransform();
        });

        viewport.addEventListener("mouseup", stopDragging);
        viewport.addEventListener("mouseleave", stopDragging);

        // Add global mouse up handler
        window.addEventListener("mouseup", stopDragging);
        window.addEventListener("blur", stopDragging);

        window.addEventListener("resize", handleResize);

        const getTouchDistance = (touches) => {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        };

        viewport.style.cursor = "grab";
    })();
</script>
